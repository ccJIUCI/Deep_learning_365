ğŸ¨ æœ¬æ–‡ä¸ºğŸ”—365å¤©æ·±åº¦å­¦ä¹ è®­ç»ƒè¥ ä¸­çš„å­¦ä¹ è®°å½•åšå®¢


ğŸ¦ å‚è€ƒæ–‡ç« ï¼š[365å¤©æ·±åº¦å­¦ä¹ è®­ç»ƒè¥-ç¬¬Y4å‘¨ï¼šcommon.pyæ–‡ä»¶è§£è¯»


* 1.1autopad éƒ¨åˆ†,è¿™éƒ¨åˆ†æ˜¯æ ¹æ®è¾“å…¥çš„å·ç§¯æ ¸kçš„å¤§å°æ¥è‡ªåŠ¨è®¡ç®—paddingçš„å€¼
```python
def autopad(k, p=None, d=1):  # kernel, padding, dilation
    # Pad to 'same' shape outputs
    if d > 1:
        k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k]  # actual kernel-size
    if p is None:
        p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad
    return p
```
* 1.2 Convå±‚ï¼Œæ˜¯æ•´ä¸ªç½‘ç»œæ¶æ„å½“ä¸­æœ€ä¸ºåŸºç¡€çš„æ¨¡å—
```python
class Conv(nn.Module):
    # Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation)
    default_act = nn.SiLU()  # default activation

    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):
        ''' åœ¨Focusã€Bottleneckã€BottleneckCSPã€C3ã€SPPã€DWConvã€TransformerBlockç­‰æ¨¡å—ä¸­è°ƒç”¨
        Standard convolution : conv + BN + act
        :params c1: è¾“å…¥çš„channelå€¼
        :params c2: è¾“å‡ºçš„channelå€¼
        :params k: å·ç§¯çš„kernel_size
        :params s: å·ç§¯çš„stride
        :params p: å·ç§¯çš„paddingï¼Œé»˜è®¤æ˜¯Noneï¼Œå¯ä»¥é€šè¿‡autopadè‡ªè¡Œè®¡ç®—éœ€è¦çš„paddingå€¼
        :params g: å·ç§¯çš„groupsæ•°ï¼Œ1å°±æ˜¯æ™®é€šçš„å·ç§¯ï¼Œ>1å°±æ˜¯æ·±åº¦å¯åˆ†ç¦»å·ç§¯ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„æ·±åº¦å¯åˆ†ç¦»å·ç§¯å’Œæ™®é€šå·ç§¯çš„åŒºåˆ«
        :params act: æ¿€æ´»å‡½æ•°ç±»å‹ï¼ŒTrueå°±æ˜¯SiLU()/Swishï¼ŒFalseå°±æ˜¯ä¸ä½¿ç”¨æ¿€æ´»å‡½æ•°ï¼Œç±»å‹æ˜¯nn.Moduleå°±ä½¿ç”¨ä¼ è¿›æ¥çš„æ¿€æ´»å‡½æ•°ç±»å‹
        '''
        super().__init__()
        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)
        self.bn = nn.BatchNorm2d(c2)
        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()

    def forward(self, x):
        return self.act(self.bn(self.conv(x)))

    def forward_fuse(self, x):
        ''' ç”¨äºModelç±»çš„fuseå‡½æ•°
        èåˆ Conv + BN åŠ é€Ÿæ¨ç†ï¼Œä¸€èˆ¬ç”¨äºæµ‹è¯•/éªŒè¯é˜¶æ®µ
        '''
        return self.act(self.conv(x))
```
* 1.3 Focus æ­¤æ¨¡å—ä¸»è¦æ˜¯å¯¹äºå›¾ç‰‡è¿›è¡Œä¸€ä¸ªåˆ‡ç‰‡ï¼Œç„¶åå°†ä¿¡æ¯é›†ä¸­åˆ°ç¬¬äºŒä¸ªç»´åº¦ä¸Šå»
```python
class Focus(nn.Module):
    # Focus wh information into c-space æŠŠå®½åº¦wå’Œé«˜åº¦hçš„ä¿¡æ¯æ•´åˆåˆ°cç©ºé—´ä¸­
    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):  # ch_in, ch_out, kernel, stride, padding, groups
        ''' åœ¨yolo.pyçš„parse_modelå‡½æ•°ä¸­è¢«è°ƒç”¨
        ç†è®ºï¼šä»é«˜åˆ†è¾¨ç‡å›¾åƒä¸­ï¼Œå‘¨æœŸæ€§çš„æŠ½å‡ºåƒç´ ç‚¹é‡æ„åˆ°ä½åˆ†è¾¨ç‡å›¾åƒä¸­ï¼Œå³å°†å›¾åƒç›¸é‚»çš„å››ä¸ªä½ç½®è¿›è¡Œå †å ï¼Œ
        èšé›†whç»´åº¦ä¿¡æ¯åˆ°cé€šé“ä¸­ï¼Œæé«˜æ¯ä¸ªç‚¹çš„æ„Ÿå—é‡ï¼Œå¹¶å‡å°‘åŸå§‹ä¿¡æ¯çš„ä¸¢å¤±ï¼Œè¯¥æ¨¡å—çš„è®¾è®¡ä¸»è¦æ˜¯å‡å°‘è®¡ç®—é‡åŠ å¿«é€Ÿåº¦ã€‚
        å…ˆåš4ä¸ªsliceï¼Œå†concatï¼Œæœ€ååœ¨åšConv
        sliceå (b1,c1,w,h) -> åˆ†æˆ4ä¸ªsliceï¼Œæ¯ä¸ªslice(b,c1,w/2,h/2)
        concat(dim=1)å 4ä¸ªslice(b,c1,w/2,h/2) -> (b,4c1,w/2,h/2)
        convå (b,4c1,w/2,h/2) -> (b,c2,w/2,h/2)
        :params c1: sliceåçš„channel
        :params c2: Focusæœ€ç»ˆè¾“å‡ºçš„channel
        :params k: æœ€åå·ç§¯çš„kernel
        :params s: æœ€åå·ç§¯çš„stride
        :params p: æœ€åå·ç§¯çš„padding
        :params g: æœ€åå·ç§¯çš„åˆ†ç»„æƒ…å†µï¼Œ=1æ™®é€šå·ç§¯ï¼Œ>1æ·±åº¦å¯åˆ†ç¦»å·ç§¯
        :params act: boolæ¿€æ´»å‡½æ•°ç±»å‹ï¼Œé»˜è®¤True[SiLU()/Swish]ï¼ŒFalse[ä¸ç”¨æ¿€æ´»å‡½æ•°]
        '''        
        super().__init__()
        self.conv = Conv(c1 * 4, c2, k, s, p, g, act=act)
        # self.contract = Contract(gain=2)

    def forward(self, x):  # x(b,c,w,h) -> y(b,4c,w/2,h/2)
        ''' æœ‰ç‚¹åƒåšäº†ä¸ªä¸‹é‡‡æ · '''
        return self.conv(torch.cat((x[..., ::2, ::2], x[..., 1::2, ::2], x[..., ::2, 1::2], x[..., 1::2, 1::2]), 1))
        # return self.conv(self.contract(x))
```
* 1.4 Bottleneck
```python
class Bottleneck(nn.Module):
    # Standard bottleneck  Conv + Conv + shortcut
    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, shortcut, groups, expansion
        ''' åœ¨BottleneckCSPå’Œyolo.pyçš„parse_modelå‡½æ•°ä¸­è¢«è°ƒç”¨
        :params c1: ç¬¬ä¸€ä¸ªå·ç§¯çš„è¾“å…¥channel
        :params c2: ç¬¬äºŒä¸ªå·ç§¯çš„è¾“å…¥channel
        :params shortcut: boolå€¼ï¼Œæ˜¯å¦æœ‰shortcutè¿æ¥ï¼Œé»˜è®¤True
        :params g: å·ç§¯åˆ†ç»„çš„ä¸ªæ•°ï¼Œ=1æ™®é€šå·ç§¯ï¼Œ>1æ·±åº¦å¯åˆ†ç¦»å·ç§¯
        :params e: expansion ratioï¼Œe*c2å°±æ˜¯ç¬¬ä¸€ä¸ªå·ç§¯çš„è¾“å‡ºchannel=ç¬¬äºŒä¸ªå·ç§¯çš„è¾“å…¥channel
        '''
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)      # 1x1
        self.cv2 = Conv(c_, c2, 3, 1, g=g) # 3x3
        self.add = shortcut and c1 == c2   # shortcut=Ture & c1==c2 æ‰èƒ½åšshortcut

    def forward(self, x):
        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))
```
* 1.5 BottleneckCSP è¿™ä¸ªæ¨¡å—å’Œä¸Šé¢yolov5sä¸­çš„C3æ¨¡å—ç­‰æ•ˆï¼Œå¦‚æœè¦ç”¨çš„è¯ç›´æ¥åœ¨yolov5s.yamlæ–‡ä»¶ä¸­å°†C3æ”¹æˆBottleneckCSPå³å¯ï¼Œä½†ä¸€èˆ¬æ¥è¯´ä¸ç”¨æ”¹ï¼Œå› ä¸ºC3æ›´å¥½ã€‚
```python
class BottleneckCSP(nn.Module):
    # CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks
    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion
        ''' åœ¨C3æ¨¡å—å’Œyolo.pyçš„parse_modelå‡½æ•°ä¸­è¢«è°ƒç”¨
        :params c1: æ•´ä¸ªBottleneckCSPçš„è¾“å…¥channel
        :params c2: æ•´ä¸ªBottleneckCSPçš„è¾“å‡ºchannel
        :params n: æœ‰nä¸ªBottleneck
        :params shortcut: boolå€¼ï¼ŒBottleneckä¸­æ˜¯å¦æœ‰shortcutï¼Œé»˜è®¤True
        :params g: Bottleneckä¸­çš„3x3å·ç§¯ç±»å‹ï¼Œ=1æ™®é€šå·ç§¯ï¼Œ>1æ·±åº¦å¯åˆ†ç¦»å·ç§¯
        :params e: expansion ratioï¼Œe*c2=ä¸­é—´å…¶å®ƒæ‰€æœ‰å±‚çš„å·ç§¯æ ¸ä¸ªæ•°=ä¸­é—´æ‰€æœ‰å±‚çš„çš„è¾“å…¥è¾“å‡ºchannel
        '''
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)
        self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)
        self.cv4 = Conv(2 * c_, c2, 1, 1)
        self.bn = nn.BatchNorm2d(2 * c_)  # applied to cat(cv2, cv3)  2*c_
        self.act = nn.SiLU()
        # å åŠ næ¬¡Bottleneck
        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))

    def forward(self, x):
        y1 = self.cv3(self.m(self.cv1(x)))
        y2 = self.cv2(x)
        return self.cv4(self.act(self.bn(torch.cat((y1, y2), 1))))
```
* 1.6 C3è¿™ä¸ªæ¨¡å—æ˜¯ä¸€ç§ç®€åŒ–çš„BottleneckCSPï¼Œå› ä¸ºé™¤äº†Bottleneckéƒ¨åˆ†åªæœ‰3ä¸ªå·ç§¯ï¼Œå¯ä»¥å‡å°‘å‚æ•°ï¼Œæ‰€ä»¥å–åC3ã€‚
```python
class C3(nn.Module):
    # CSP Bottleneck with 3 convolutions
    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion
        ''' åœ¨C3RTæ¨¡å—å’Œyolo.pyçš„parse_modelå‡½æ•°ä¸­è¢«è°ƒç”¨
        :params c1: æ•´ä¸ªC3çš„è¾“å…¥channel
        :params c2: æ•´ä¸ªC3çš„è¾“å‡ºchannel
        :params n: æœ‰nä¸ªå­æ¨¡å—[Bottleneck/CrossConv]
        :params shortcut: boolå€¼ï¼Œå­æ¨¡å—[Bottlenec/CrossConv]ä¸­æ˜¯å¦æœ‰shortcutï¼Œé»˜è®¤True
        :params g: å­æ¨¡å—[Bottlenec/CrossConv]ä¸­çš„3x3å·ç§¯ç±»å‹ï¼Œ=1æ™®é€šå·ç§¯ï¼Œ>1æ·±åº¦å¯åˆ†ç¦»å·ç§¯
        :params e: expansion ratioï¼Œe*c2=ä¸­é—´å…¶å®ƒæ‰€æœ‰å±‚çš„å·ç§¯æ ¸ä¸ªæ•°=ä¸­é—´æ‰€æœ‰å±‚çš„çš„è¾“å…¥è¾“å‡ºchannel
        '''
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c1, c_, 1, 1)
        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)
        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))
        # å®éªŒæ€§ CrossConv
        #self.m = nn.Sequential(*[CrossConv(c_, c_, 3, 1, g, 1.0, shortcut) for _ in range(n)])

    def forward(self, x):
        return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1))
```
* 1.7 SPP ç©ºé—´é‡‘å­—å¡”æ± åŒ–
å°†è¾“å…¥çš„å·ç§¯ç‰¹å¾åˆ†æˆä¸åŒçš„å°ºå¯¸ï¼Œç„¶åæ¯ä¸ªå°ºå¯¸æå–å›ºå®šç»´åº¦çš„ç‰¹å¾ï¼Œæœ€åå°†è¿™äº›ç‰¹å¾æ‹¼æ¥æˆä¸€ä¸ªå›ºå®šçš„ç»´åº¦
```python
class SPP(nn.Module):
    # Spatial Pyramid Pooling (SPP) layer https://arxiv.org/abs/1406.4729
    def __init__(self, c1, c2, k=(5, 9, 13)):
        ''' åœ¨yolo.pyçš„parse_modelå‡½æ•°ä¸­è¢«è°ƒç”¨
        :params c1: SPPæ¨¡å—çš„è¾“å…¥channel
        :params c2: SPPæ¨¡å—çš„è¾“å‡ºchannel
        :params k: ä¿å­˜ç€ä¸‰ä¸ªmaxpoolçš„å·ç§¯æ ¸å¤§å°ï¼Œé»˜è®¤æ˜¯(5, 9, 13)
        '''
        super().__init__()
        c_ = c1 // 2  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)                # ç¬¬ä¸€å±‚å·ç§¯
        self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1) # æœ€åä¸€å±‚å·ç§¯ï¼Œ+1æ˜¯å› ä¸ºæœ‰len(k)+1ä¸ªè¾“å…¥
        self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])

    def forward(self, x):
        x = self.cv1(x)
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')  # suppress torch 1.9.0 max_pool2d() warning
            return self.cv2(torch.cat([x] + [m(x) for m in self.m], 1))


```




