æœ¬å‘¨ä»»åŠ¡ï¼šå°†yolov5sç½‘ç»œæ¨¡å‹ä¸­çš„C3æ¨¡å—æŒ‰ç…§ä¸‹å›¾æ–¹å¼ä¿®æ”¹å½¢æˆC2æ¨¡å—ï¼Œå¹¶å°†C2æ¨¡å—æ’å…¥ç¬¬2å±‚ä¸ç¬¬3å±‚ä¹‹é—´ï¼Œä¸”è·‘é€šyolov5ã€‚
ğŸ’«ä»»åŠ¡æç¤ºï¼š
    æç¤º1ï¼šéœ€è¦ä¿®æ”¹./models/common.pyã€./models/yolo.pyã€./models/yolov5s.yamlæ–‡ä»¶
    æç¤º2ï¼šC2æ¨¡å—ä¸C3æ¨¡å—æ˜¯éå¸¸ç›¸ä¼¼çš„ä¸¤ä¸ªæ¨¡å—ï¼Œæˆ‘ä»¬è¦æ’å…¥C2åˆ°æ¨¡å‹å½“ä¸­ï¼Œåªéœ€è¦æ‰¾åˆ°å“ªé‡Œæœ‰C3æ¨¡å—ï¼Œç„¶ååœ¨å…¶é™„è¿‘åŠ ä¸ŠC2å³å¯ï¼ˆæ’å…¥åˆ°Backboneä¸­ï¼‰ã€‚
# å¯¼å…¥å¯¹åº”çš„åŒ…
```python
import argparse     # è§£æå‘½ä»¤è¡Œå‚æ•°æ¨¡å—
import contextlib
import os
import platform
import sys          # sysç³»ç»Ÿæ¨¡å—ï¼ŒåŒ…å«äº†ä¸Pythonè§£é‡Šå™¨å’Œå®ƒçš„ç¯å¢ƒæœ‰å…³çš„å‡½æ•°
from copy import deepcopy  # æ•°æ®æ‹·è´æ¨¡å—ï¼Œæ·±æ‹·è´
from pathlib import Path   # Pathå°†strè½¬æ¢ä¸ºPathå¯¹è±¡ï¼Œä½¿å­—ç¬¦ä¸²è·¯å¾„æ˜“äºæ“ä½œ
 
FILE = Path(__file__).resolve()
ROOT = FILE.parents[1]  # YOLOv5 root directory
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))  # add ROOT to PATH
if platform.system() != 'Windows':
    ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative
 
from models.common import *
from models.experimental import *
from utils.autoanchor import check_anchor_order
from utils.general import LOGGER, check_version, check_yaml, make_divisible, print_args
from utils.plots import feature_visualization
from utils.torch_utils import (fuse_conv_and_bn, initialize_weights, model_info, profile, scale_img, select_device,
                               time_sync)
 
# å¯¼å…¥thopåŒ…ï¼Œç”¨äºè®¡ç®—FLOPs
try:
    import thop  # for FLOPs computation
except ImportError:
    thop = None
```
# æ”¹åŠ¨parse_modelå‡½æ•°
```python
def parse_model(d, ch):  # model_dict, input_channels(3)
    # Parse a YOLOv5 model.yaml dictionary
    ''' ç”¨åœ¨ä¸Šé¢DetectionModelæ¨¡å—ä¸­
    è§£ææ¨¡å‹æ–‡ä»¶(å­—å…¸å½¢å¼)ï¼Œå¹¶æ­å»ºç½‘ç»œç»“æ„
    è¿™ä¸ªå‡½æ•°å…¶å®ä¸»è¦åšçš„å°±æ˜¯ï¼š
        æ›´æ–°å½“å‰å±‚çš„args(å‚æ•°)ï¼Œè®¡ç®—c2(å½“å‰å±‚çš„è¾“å‡ºchannel)
        ->ä½¿ç”¨å½“å‰å±‚çš„å‚æ•°æ­å»ºå½“å‰å±‚
        ->ç”Ÿæˆ layers + save
    :params d: model_dictæ¨¡å‹æ–‡ä»¶ï¼Œå­—å…¸å½¢å¼{dice: 7}(yolov5s.yamlä¸­çš„6ä¸ªå…ƒç´  + ch)
    :params ch: è®°å½•æ¨¡å‹æ¯ä¸€å±‚çš„è¾“å‡ºchannelï¼Œåˆå§‹ch=[3]ï¼Œåé¢ä¼šåˆ é™¤
    :return nn.Sequential(*layers): ç½‘ç»œçš„æ¯ä¸€å±‚çš„å±‚ç»“æ„
    :return sorted(save): æŠŠæ‰€æœ‰å±‚ç»“æ„ä¸­çš„fromä¸æ˜¯-1çš„å€¼è®°ä¸‹ï¼Œå¹¶æ’åº[4,6,10,14,17,20,23]
    '''
    LOGGER.info(f"\n{'':>3}{'from':>18}{'n':>3}{'params':>10}  {'module':<40}{'arguments':<30}")
    # è¯»å–å­—å…¸dä¸­çš„anchorså’Œparameters(nc,depth_multiple,width_multiple)
    anchors, nc, gd, gw, act = d['anchors'], d['nc'], d['depth_multiple'], d['width_multiple'], d.get('activation')
    if act:
        Conv.default_act = eval(act)  # redefine default activation, i.e. Conv.default_act = nn.SiLU()
        LOGGER.info(f"{colorstr('activation:')} {act}")  # print
    # na: number of anchors æ¯ä¸€ä¸ªpredict headä¸Šçš„anchoræ•°=3
    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors
    # no: number of outputs æ¯ä¸€ä¸ªpredict headå±‚çš„è¾“å‡ºchannel=anchors*(classes+5)=75(VOC)
    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)
 
    ''' å¼€å§‹æ­å»ºç½‘ç»œ
    layers: ä¿å­˜æ¯ä¸€å±‚çš„å±‚ç»“æ„
    save: è®°å½•ä¸‹æ‰€æœ‰å±‚ç»“æ„ä¸­fromä¸æ˜¯-1çš„å±‚ç»“æ„åºå·
    c2: ä¿å­˜å½“å‰å±‚çš„è¾“å‡ºchannel
    '''
    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out
    # from: å½“å‰å±‚è¾“å…¥æ¥è‡ªå“ªäº›å±‚
    # number: å½“å‰å±‚æ•°ï¼Œåˆå®š
    # module: å½“å‰å±‚ç±»åˆ«
    # args: å½“å‰å±‚ç±»å‚æ•°ï¼Œåˆå®š
    # éå†backboneå’Œheadçš„æ¯ä¸€å±‚
    for i, (f, n, m, args) in enumerate(d['backbone'] + d['head']):  # from, number, module, args
        # å¾—åˆ°å½“å‰å±‚çš„çœŸå®ç±»åï¼Œä¾‹å¦‚ï¼šm = Focus -> <class 'models.common.Focus'>
        m = eval(m) if isinstance(m, str) else m  # eval strings
        # æ²¡ä»€ä¹ˆç”¨
        for j, a in enumerate(args):
            with contextlib.suppress(NameError):
                args[j] = eval(a) if isinstance(a, str) else a  # eval strings
 
        # --------------------æ›´æ–°å½“å‰å±‚çš„args(å‚æ•°)ï¼Œè®¡ç®—c2(å½“å‰å±‚çš„è¾“å‡ºchannel)--------------------
        # depth gain æ§åˆ¶æ·±åº¦ï¼Œå¦‚yolov5s: n*0.33ï¼Œn: å½“å‰æ¨¡å—çš„æ¬¡æ•°(é—´æ¥æ§åˆ¶æ·±åº¦)
        n = n_ = max(round(n * gd), 1) if n > 1 else n  # depth gain
        if m in {
                Conv, GhostConv, Bottleneck, GhostBottleneck, SPP, SPPF, DWConv, MixConv2d, Focus, CrossConv,
                BottleneckCSP, C3, C3TR, C3SPP, C3Ghost, nn.ConvTranspose2d, DWConvTranspose2d, C3x}:
            # c1: å½“å‰å±‚çš„è¾“å…¥channelæ•°; c2: å½“å‰å±‚çš„è¾“å‡ºchannelæ•°(åˆå®š); ch: è®°å½•ç€æ‰€æœ‰å±‚çš„è¾“å‡ºchannelæ•°
            c1, c2 = ch[f], args[0]
            # no=75ï¼Œåªæœ‰æœ€åä¸€å±‚c2=noï¼Œæœ€åä¸€å±‚ä¸ç”¨æ§åˆ¶å®½åº¦ï¼Œè¾“å‡ºchannelå¿…é¡»æ˜¯no
            if c2 != no:  # if not output
                # width gain æ§åˆ¶å®½åº¦ï¼Œå¦‚yolov5s: c2*0.5; c2: å½“å‰å±‚çš„æœ€ç»ˆè¾“å‡ºchannelæ•°(é—´æ¥æ§åˆ¶å®½åº¦)
                c2 = make_divisible(c2 * gw, 8)
 
            # åœ¨åˆå§‹argsçš„åŸºç¡€ä¸Šæ›´æ–°ï¼ŒåŠ å…¥å½“å‰å±‚çš„è¾“å…¥channelå¹¶æ›´æ–°å½“å‰å±‚
            # [in_channels, out_channels, *args[1:]]
            args = [c1, c2, *args[1:]]
            # å¦‚æœå½“å‰å±‚æ˜¯BottleneckCSP/C3/C3TR/C3Ghost/C3xï¼Œåˆ™éœ€è¦åœ¨argsä¸­åŠ å…¥Bottleneckçš„ä¸ªæ•°
            # [in_channels, out_channels, Bottleneckä¸ªæ•°, Bool(shortcutæœ‰æ— æ ‡è®°)]
            if m in {BottleneckCSP, C3, C3TR, C3Ghost, C3x}:
                args.insert(2, n)  # number of repeats åœ¨ç¬¬äºŒä¸ªä½ç½®æ’å…¥Bottleneckçš„ä¸ªæ•°n
                n = 1 # æ¢å¤é»˜è®¤å€¼1
        elif m is nn.BatchNorm2d:
            # BNå±‚åªéœ€è¦è¿”å›ä¸Šä¸€å±‚çš„è¾“å‡ºchannel
            args = [ch[f]]
        elif m is Concat:
            # Concatå±‚åˆ™å°†fä¸­æ‰€æœ‰çš„è¾“å‡ºç´¯åŠ å¾—åˆ°è¿™å±‚çš„è¾“å‡ºchannel
            c2 = sum(ch[x] for x in f)
        # TODO: channel, gw, gd
        elif m in {Detect, Segment}:  # Detect/Segment(YOLO Layer)å±‚
            # åœ¨argsä¸­åŠ å…¥ä¸‰ä¸ªDetectå±‚çš„è¾“å‡ºchannel
            args.append([ch[x] for x in f])
            if isinstance(args[1], int):  # number of anchors å‡ ä¹ä¸æ‰§è¡Œ
                args[1] = [list(range(args[1] * 2))] * len(f)
            if m is Segment:
                args[3] = make_divisible(args[3] * gw, 8)
        elif m is Contract:  # ä¸æ€ä¹ˆç”¨
            c2 = ch[f] * args[0] ** 2
        elif m is Expand:  # ä¸æ€ä¹ˆç”¨
            c2 = ch[f] // args[0] ** 2
        else:  # Upsample
            c2 = ch[f]  # argsä¸å˜
        # -------------------------------------------------------------------------------------------
 
        # m_: å¾—åˆ°å½“å‰å±‚çš„moduleï¼Œå¦‚æœn>1å°±åˆ›å»ºå¤šä¸ªm(å½“å‰å±‚ç»“æ„)ï¼Œå¦‚æœn=1å°±åˆ›å»ºä¸€ä¸ªm
        m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n > 1 else m(*args)  # module
        # æ‰“å°å½“å‰å±‚ç»“æ„çš„ä¸€äº›åŸºæœ¬ä¿¡æ¯
        t = str(m)[8:-2].replace('__main__.', '')  # module type  <'modules.common.Focus'>
        np = sum(x.numel() for x in m_.parameters())  # number params è®¡ç®—è¿™ä¸€å±‚çš„å‚æ•°é‡
        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, 'from' index, type, number params
        LOGGER.info(f'{i:>3}{str(f):>18}{n_:>3}{np:10.0f}  {t:<40}{str(args):<30}')  # print
        # æŠŠæ‰€æœ‰å±‚ç»“æ„ä¸­çš„fromä¸æ˜¯-1çš„å€¼è®°ä¸‹ [6,4,14,10,17,20,23]
        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist
        # å°†å½“å‰å±‚ç»“æ„moduleåŠ å…¥layersä¸­
        layers.append(m_)
        if i == 0:
            ch = []  # å»é™¤è¾“å…¥channel[3]
        # æŠŠå½“å‰å±‚çš„è¾“å‡ºchannelæ•°åŠ å…¥ch
        ch.append(c2)
    return nn.Sequential(*layers), sorted(save)
```

è°ƒæ•´æ¨¡å‹
```python
#C2æ¨¡å—
class C2(nn.Module):
    # CSP Bottleneck with 3 convolutions
    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion
        super().__init__()
        c_ = int(c2 * 0.5)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c1, c_, 1, 1)
        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))
 
    def forward(self, x):
        # ç§»é™¤cv3å·ç§¯å±‚åï¼Œè‹¥è¦ä¿æŒæœ€ç»ˆè¾“å‡ºçš„channelä»ä¸ºc2ï¼Œåˆ™ä¸­é—´å±‚çš„channeléœ€ä¸ºc2/2
        # è®¾ç½®e=0.5å³å¯ï¼Œå–é»˜è®¤å€¼ä¸å˜
        return torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1)
 
 
class C3(nn.Module):
    # CSP Bottleneck with 3 convolutions
    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion
        ''' åœ¨C3RTæ¨¡å—å’Œyolo.pyçš„parse_modelå‡½æ•°ä¸­è¢«è°ƒç”¨
        :params c1: æ•´ä¸ªC3çš„è¾“å…¥channel
        :params c2: æ•´ä¸ªC3çš„è¾“å‡ºchannel
        :params n: æœ‰nä¸ªå­æ¨¡å—[Bottleneck/CrossConv]
        :params shortcut: boolå€¼ï¼Œå­æ¨¡å—[Bottlenec/CrossConv]ä¸­æ˜¯å¦æœ‰shortcutï¼Œé»˜è®¤True
        :params g: å­æ¨¡å—[Bottlenec/CrossConv]ä¸­çš„3x3å·ç§¯ç±»å‹ï¼Œ=1æ™®é€šå·ç§¯ï¼Œ>1æ·±åº¦å¯åˆ†ç¦»å·ç§¯
        :params e: expansion ratioï¼Œe*c2=ä¸­é—´å…¶å®ƒæ‰€æœ‰å±‚çš„å·ç§¯æ ¸ä¸ªæ•°=ä¸­é—´æ‰€æœ‰å±‚çš„çš„è¾“å…¥è¾“å‡ºchannel
        '''
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c1, c_, 1, 1)
        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)
        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))
        # å®éªŒæ€§ CrossConv
        #self.m = nn.Sequential(*[CrossConv(c_, c_, 3, 1, g, 1.0, shortcut) for _ in range(n)])
 
    def forward(self, x):
        return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1))
        
#åœ¨parse_modelä¸­å¢åŠ å¯¹C2çš„è§£æ
def parse_model(d, ch):  # model_dict, input_channels(3)
    # Parse a YOLOv5 model.yaml dictionary
    ''' ç”¨åœ¨ä¸Šé¢DetectionModelæ¨¡å—ä¸­
    è§£ææ¨¡å‹æ–‡ä»¶(å­—å…¸å½¢å¼)ï¼Œå¹¶æ­å»ºç½‘ç»œç»“æ„
    è¿™ä¸ªå‡½æ•°å…¶å®ä¸»è¦åšçš„å°±æ˜¯ï¼š
        æ›´æ–°å½“å‰å±‚çš„args(å‚æ•°)ï¼Œè®¡ç®—c2(å½“å‰å±‚çš„è¾“å‡ºchannel)
        ->ä½¿ç”¨å½“å‰å±‚çš„å‚æ•°æ­å»ºå½“å‰å±‚
        ->ç”Ÿæˆ layers + save
    :params d: model_dictæ¨¡å‹æ–‡ä»¶ï¼Œå­—å…¸å½¢å¼{dice: 7}(yolov5s.yamlä¸­çš„6ä¸ªå…ƒç´  + ch)
    :params ch: è®°å½•æ¨¡å‹æ¯ä¸€å±‚çš„è¾“å‡ºchannelï¼Œåˆå§‹ch=[3]ï¼Œåé¢ä¼šåˆ é™¤
    :return nn.Sequential(*layers): ç½‘ç»œçš„æ¯ä¸€å±‚çš„å±‚ç»“æ„
    :return sorted(save): æŠŠæ‰€æœ‰å±‚ç»“æ„ä¸­çš„fromä¸æ˜¯-1çš„å€¼è®°ä¸‹ï¼Œå¹¶æ’åº[4,6,10,14,17,20,23]
    '''
    LOGGER.info(f"\n{'':>3}{'from':>18}{'n':>3}{'params':>10}  {'module':<40}{'arguments':<30}")
    # è¯»å–å­—å…¸dä¸­çš„anchorså’Œparameters(nc,depth_multiple,width_multiple)
    anchors, nc, gd, gw, act = d['anchors'], d['nc'], d['depth_multiple'], d['width_multiple'], d.get('activation')
    if act:
        Conv.default_act = eval(act)  # redefine default activation, i.e. Conv.default_act = nn.SiLU()
        LOGGER.info(f"{colorstr('activation:')} {act}")  # print
    # na: number of anchors æ¯ä¸€ä¸ªpredict headä¸Šçš„anchoræ•°=3
    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors
    # no: number of outputs æ¯ä¸€ä¸ªpredict headå±‚çš„è¾“å‡ºchannel=anchors*(classes+5)=75(VOC)
    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)
 
    ''' å¼€å§‹æ­å»ºç½‘ç»œ
    layers: ä¿å­˜æ¯ä¸€å±‚çš„å±‚ç»“æ„
    save: è®°å½•ä¸‹æ‰€æœ‰å±‚ç»“æ„ä¸­fromä¸æ˜¯-1çš„å±‚ç»“æ„åºå·
    c2: ä¿å­˜å½“å‰å±‚çš„è¾“å‡ºchannel
    '''
    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out
    # from: å½“å‰å±‚è¾“å…¥æ¥è‡ªå“ªäº›å±‚
    # number: å½“å‰å±‚æ•°ï¼Œåˆå®š
    # module: å½“å‰å±‚ç±»åˆ«
    # args: å½“å‰å±‚ç±»å‚æ•°ï¼Œåˆå®š
    # éå†backboneå’Œheadçš„æ¯ä¸€å±‚
    for i, (f, n, m, args) in enumerate(d['backbone'] + d['head']):  # from, number, module, args
        # å¾—åˆ°å½“å‰å±‚çš„çœŸå®ç±»åï¼Œä¾‹å¦‚ï¼šm = Focus -> <class 'models.common.Focus'>
        m = eval(m) if isinstance(m, str) else m  # eval strings
        # æ²¡ä»€ä¹ˆç”¨
        for j, a in enumerate(args):
            with contextlib.suppress(NameError):
                args[j] = eval(a) if isinstance(a, str) else a  # eval strings
 
        # --------------------æ›´æ–°å½“å‰å±‚çš„args(å‚æ•°)ï¼Œè®¡ç®—c2(å½“å‰å±‚çš„è¾“å‡ºchannel)--------------------
        # depth gain æ§åˆ¶æ·±åº¦ï¼Œå¦‚yolov5s: n*0.33ï¼Œn: å½“å‰æ¨¡å—çš„æ¬¡æ•°(é—´æ¥æ§åˆ¶æ·±åº¦)
        n = n_ = max(round(n * gd), 1) if n > 1 else n  # depth gain
        if m in {
                Conv, GhostConv, Bottleneck, GhostBottleneck, SPP, SPPF, DWConv, MixConv2d, Focus, CrossConv,
                BottleneckCSP, C2, C3, C3TR, C3SPP, C3Ghost, nn.ConvTranspose2d, DWConvTranspose2d, C3x}:
            # c1: å½“å‰å±‚çš„è¾“å…¥channelæ•°; c2: å½“å‰å±‚çš„è¾“å‡ºchannelæ•°(åˆå®š); ch: è®°å½•ç€æ‰€æœ‰å±‚çš„è¾“å‡ºchannelæ•°
            c1, c2 = ch[f], args[0]
            # no=75ï¼Œåªæœ‰æœ€åä¸€å±‚c2=noï¼Œæœ€åä¸€å±‚ä¸ç”¨æ§åˆ¶å®½åº¦ï¼Œè¾“å‡ºchannelå¿…é¡»æ˜¯no
            if c2 != no:  # if not output
                # width gain æ§åˆ¶å®½åº¦ï¼Œå¦‚yolov5s: c2*0.5; c2: å½“å‰å±‚çš„æœ€ç»ˆè¾“å‡ºchannelæ•°(é—´æ¥æ§åˆ¶å®½åº¦)
                c2 = make_divisible(c2 * gw, 8)
 
            # åœ¨åˆå§‹argsçš„åŸºç¡€ä¸Šæ›´æ–°ï¼ŒåŠ å…¥å½“å‰å±‚çš„è¾“å…¥channelå¹¶æ›´æ–°å½“å‰å±‚
            # [in_channels, out_channels, *args[1:]]
            args = [c1, c2, *args[1:]]
            # å¦‚æœå½“å‰å±‚æ˜¯BottleneckCSP/C2/C3/C3TR/C3Ghost/C3xï¼Œåˆ™éœ€è¦åœ¨argsä¸­åŠ å…¥Bottleneckçš„ä¸ªæ•°
            # [in_channels, out_channels, Bottleneckä¸ªæ•°, Bool(shortcutæœ‰æ— æ ‡è®°)]
            if m in {BottleneckCSP, C2, C3, C3TR, C3Ghost, C3x}:
                args.insert(2, n)  # number of repeats åœ¨ç¬¬äºŒä¸ªä½ç½®æ’å…¥Bottleneckçš„ä¸ªæ•°n
                n = 1 # æ¢å¤é»˜è®¤å€¼1
        elif m is nn.BatchNorm2d:
            # BNå±‚åªéœ€è¦è¿”å›ä¸Šä¸€å±‚çš„è¾“å‡ºchannel
            args = [ch[f]]
        elif m is Concat:
            # Concatå±‚åˆ™å°†fä¸­æ‰€æœ‰çš„è¾“å‡ºç´¯åŠ å¾—åˆ°è¿™å±‚çš„è¾“å‡ºchannel
            c2 = sum(ch[x] for x in f)
        # TODO: channel, gw, gd
        elif m in {Detect, Segment}:  # Detect/Segment(YOLO Layer)å±‚
            # åœ¨argsä¸­åŠ å…¥ä¸‰ä¸ªDetectå±‚çš„è¾“å‡ºchannel
            args.append([ch[x] for x in f])
            if isinstance(args[1], int):  # number of anchors å‡ ä¹ä¸æ‰§è¡Œ
                args[1] = [list(range(args[1] * 2))] * len(f)
            if m is Segment:
                args[3] = make_divisible(args[3] * gw, 8)
        elif m is Contract:  # ä¸æ€ä¹ˆç”¨
            c2 = ch[f] * args[0] ** 2
        elif m is Expand:  # ä¸æ€ä¹ˆç”¨
            c2 = ch[f] // args[0] ** 2
        else:  # Upsample
            c2 = ch[f]  # argsä¸å˜
        # -------------------------------------------------------------------------------------------
 
        # m_: å¾—åˆ°å½“å‰å±‚çš„moduleï¼Œå¦‚æœn>1å°±åˆ›å»ºå¤šä¸ªm(å½“å‰å±‚ç»“æ„)ï¼Œå¦‚æœn=1å°±åˆ›å»ºä¸€ä¸ªm
        m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n > 1 else m(*args)  # module
        # æ‰“å°å½“å‰å±‚ç»“æ„çš„ä¸€äº›åŸºæœ¬ä¿¡æ¯
        t = str(m)[8:-2].replace('__main__.', '')  # module type  <'modules.common.Focus'>
        np = sum(x.numel() for x in m_.parameters())  # number params è®¡ç®—è¿™ä¸€å±‚çš„å‚æ•°é‡
        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, 'from' index, type, number params
        LOGGER.info(f'{i:>3}{str(f):>18}{n_:>3}{np:10.0f}  {t:<40}{str(args):<30}')  # print
        # æŠŠæ‰€æœ‰å±‚ç»“æ„ä¸­çš„fromä¸æ˜¯-1çš„å€¼è®°ä¸‹ [6,4,14,10,17,20,23]
        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist
        # å°†å½“å‰å±‚ç»“æ„moduleåŠ å…¥layersä¸­
        layers.append(m_)
        if i == 0:
            ch = []  # å»é™¤è¾“å…¥channel[3]
        # æŠŠå½“å‰å±‚çš„è¾“å‡ºchannelæ•°åŠ å…¥ch
        ch.append(c2)
    return nn.Sequential(*layers), sorted(save)
```
